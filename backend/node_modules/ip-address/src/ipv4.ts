/* eslint-disable no-param-reassign */

import * as common from './common';
import * as constants from './v4/constants';
import { AddressError } from './address-error';

/**
 * Represents an IPv4 address
 * @class Address4
 * @param {string} address - An IPv4 address string
 */
export class Address4 {
  address: string;
  addressMinusSuffix?: string;
  groups: number = constants.GROUPS;
  parsedAddress: string[] = [];
  parsedSubnet: string = '';
  subnet: string = '/32';
  subnetMask: number = 32;
  v4: boolean = true;

  constructor(address: string) {
    this.address = address;

    const subnet = constants.RE_SUBNET_STRING.exec(address);

    if (subnet) {
      this.parsedSubnet = subnet[0].replace('/', '');
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;

      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
        throw new AddressError('Invalid subnet mask.');
      }

      address = address.replace(constants.RE_SUBNET_STRING, '');
    }

    this.addressMinusSuffix = address;

    this.parsedAddress = this.parse(address);
  }

  static isValid(address: string): boolean {
    try {
      // eslint-disable-next-line no-new
      new Address4(address);

      return true;
    } catch (e) {
      return false;
    }
  }

  /*
   * Parses a v4 address
   */
  parse(address: string) {
    const groups = address.split('.');

    if (!address.match(constants.RE_ADDRESS)) {
      throw new AddressError('Invalid IPv4 address.');
    }

    return groups;
  }

  /**
   * Returns the correct form of an address
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  correctForm(): string {
    return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');
  }

  /**
   * Returns true if the address is correct, false otherwise
   * @memberof Address4
   * @instance
   * @returns {Boolean}
   */
  isCorrect = common.isCorrect(constants.BITS);

  /**
   * Converts a hex string to an IPv4 address object
   * @memberof Address4
   * @static
   * @param {string} hex - a hex string to convert
   * @returns {Address4}
   */
  static fromHex(hex: string): Address4 {
    const padded = hex.replace(/:/g, '').padStart(8, '0');
    const groups = [];
    let i;

    for (i = 0; i < 8; i += 2) {
      const h = padded.slice(i, i + 2);

      groups.push(parseInt(h, 16));
    }

    return new Address4(groups.join('.'));
  }

  /**
   * Converts an integer into a IPv4 address object
   * @memberof Address4
   * @static
   * @param {integer} integer - a number to convert
   * @returns {Address4}
   */
  static fromInteger(integer: number): Address4 {
    return Address4.fromHex(integer.toString(16));
  }

  /**
   * Return an address from in-addr.arpa form
   * @memberof Address4
   * @static
   * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
   * @returns {Adress4}
   * @example
   * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
   * address.correctForm(); // '192.0.2.42'
   */
  static fromArpa(arpaFormAddress: string): Address4 {
    // remove ending ".in-addr.arpa." or just "."
    const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, '');

    const address = leader.split('.').reverse().join('.');

    return new Address4(address);
  }

  /**
   * Converts an IPv4 address object to a hex string
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  toHex(): string {
    return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(':');
  }

  /**
   * Converts an IPv4 address object to an array of bytes
   * @memberof Address4
   * @instance
   * @returns {Array}
   */
  toArray(): number[] {
    return this.parsedAddress.map((part) => parseInt(part, 10));
  }

  /**
   * Converts an IPv4 address object to an IPv6 address group
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  toGroup6(): string {
    const output = [];
    let i;

    for (i = 0; i < constants.GROUPS; i += 2) {
      output.push(
        `${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(
          this.parsedAddress[i + 1],
        )}`,
      );
    }

    return output.join(':');
  }

  /**
   * Returns the address as a `bigint`
   * @memberof Address4
   * @instance
   * @returns {bigint}
   */
  bigInt(): bigint {
    return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join('')}`);
  }

  /**
   * Helper function getting start address.
   * @memberof Address4
   * @instance
   * @returns {bigint}
   */
  _startAddress(): bigint {
    return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);
  }

  /**
   * The first address in the range given by this address' subnet.
   